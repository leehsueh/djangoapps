from django.db import models
from django.contrib.auth.models import User
import random
# Create your models here.

# Custom manager methods for Verse
class VerseManager(models.Manager):
    # returns a list of all books in the Bible
    def get_all_books(self):
        books = self.filter(chapter_ref=1, verse_ref=1).values_list('book', flat=True)
        return books

    # assumes that the verses in Bible were inserted in order
    # which should be true using the script generated by read_bible.py
    def get_passage(self, startverse, endverse):
        if endverse:
            numverses = endverse.id - startverse.id + 1
            return self.filter(id__gte=startverse.id).order_by('id')[0:numverses]
        else:
            return [startverse]
    def get_verse(self, bookname, chpnum, versenum):
        return self.get(book__iexact=bookname,chapter_ref=chpnum,verse_ref=versenum)
    
    def get_previous_chapter(self, verse):
        """returns a tuple of (book, chapter) representing the previous chapter of given verse"""
        if verse.book == 'Genesis' and verse.chapter_ref == 1: return None
        if verse.chapter_ref > 1:
            return (verse.book, verse.chapter_ref-1)
        else:
            # get the last verse of the previous book using verse id dependency
            if verse.verse_ref == 1:
                lastverse = Verse.objects.get(id=verse.id-1)
            else:
                verse = Verse.objects.get(book__iexact=verse.book, chapter_ref=verse.chapter_ref, verse_ref=1)
                lastverse = Verse.objects.get(id=verse.id-1)
            return (lastverse.book, lastverse.chapter_ref)

    def get_next_chapter(self, verse):
        """returns a tuple of (book, chapter) representing the next chapter of given verse"""
        if verse.book == 'Revelation' and verse.chapter_ref == 22: return None
        try:
            next = Verse.objects.get(book__iexact=verse.book, chapter_ref=verse.chapter_ref+1, verse_ref=1)
        except Verse.DoesNotExist:
            next = Verse.objects.filter(book__iexact=verse.book, chapter_ref=verse.chapter_ref,verse_ref__gte=verse.verse_ref).order_by('-verse_ref')[:1]   #should get the last verse of the chapter
            next = Verse.objects.get(id=next[0].id+1)
        finally:
            return (next.book, next.chapter_ref)
    
    # validation functions
    # returns 0 if invalid; otherwise # of chapters in book
    def validate_book(self, bookname):
        chp_count = self.filter(book__iexact=bookname).filter(verse_ref=1).count()
        return chp_count
        
    def validate_chapter(self, bookname, chpnum):
        return self.filter(book__iexact=bookname, chapter_ref=chpnum).count()
        
    def validate_verse(self, bookname, chpnum, versenum):
        return self.filter(book__iexact=bookname, chapter_ref=chpnum, verse_ref=versenum).count()
        

# read only table with Bible verses
class Verse(models.Model):
    book = models.CharField(max_length=64, editable=False)
    chapter_ref = models.IntegerField(editable=False)
    verse_ref = models.IntegerField(editable=False)
    
    """TRANSLATIONS = (
    (u'KJV', u'King James Version'),
    (u'MKJV', u'Modern King James Version'),
    (u'NKJV', u'New King James Version'),
    (u'NIV', u'New International Version'),
    (u'YLT', u'Young Literal Translation'),
    )
    #translation = models.CharField(max_length=4, choices=TRANSLATIONS)"""
    
    verse_text = models.TextField(editable=False)
    
    # custom manager
    objects = VerseManager()
    
    def __unicode__(self):
        return u'%s %s:%s' % (self.book, self.chapter_ref, self.verse_ref)
        
    # returns the text of the verse
    def get_text(self):
        return u'%s' % (self.verse_text)
        
    def get_book(self):
        return u'%s' % (self.book)
        
    def get_chapter(self):
        return int(self.chapter_ref)
        
    def get_verse(self):
        return int(self.verse_ref)
    
    class Meta:
        ordering = ['id']


# create first category with id 1 to be "root" category: not displayed
class Category(models.Model):
    category = models.CharField(max_length=64, unique=True)
    parent = models.ForeignKey('self', null=True, blank=True, related_name='subcategories')
    slug = models.SlugField(max_length=64, unique=True)
    meta_notes = models.CharField(max_length=128, blank=True, null=True, help_text="Suggested parent category, or 'top' for top level category")
    created_by = models.ForeignKey(User, null=True)
    
    def __unicode__(self):
        return u'%s' % (self.category)
    
    class Meta:
        verbose_name_plural = "Categories"
        ordering = ['id']
 
# not sure if want to implement tags; used just for searching?
class Tag(models.Model):
    name = models.CharField(max_length=32, unique=True)
    slug = models.SlugField(max_length=32, unique=True)
    
    def __unicode__(self):
        return u"%s" % (self.name)
    
    class Meta:
        ordering = ['name']


# custom manager for Entry
class EntryManager(models.Manager):
    def make_entry_dicts(self, entries_values):
        """assumes entries_values is a list returned by a query appended with .values('id','title','startverse','endverse'[, 'created_by', 'num_votes'])"""
        if len(entries_values) < 1: return []
        include_user = 'created_by' in entries_values[0].keys()
        
        # get data referenced by foreign key
        # awkward syntax to make template think it's using an actual model instance
        for entry in entries_values:
            sv = Verse.objects.filter(id=entry['startverse'])[:1].values('book','chapter_ref','verse_ref')
            entry['get_book'] = sv[0]['book']
            passage_ref = str(sv[0]['chapter_ref']) + ':' + str(sv[0]['verse_ref'])
            if entry['endverse']:
                entry['get_passage_ref'] = passage_ref + '-' + str(sv[0]['verse_ref'] + entry['endverse']-entry['startverse'])
            else:
                entry['get_passage_ref'] = passage_ref
            if include_user:
                entry['created_by'] = {'username': User.objects.filter(id=entry['created_by'])[:1].values('username')[0]['username']}
        
        return entries_values
    
    def entries_created_by(self, user):
        """ assumes user is django model instance """
        return self.filter(created_by=user).exclude(removed=True).values('id','title','startverse','endverse','pub_date', 'created_by', 'num_votes')
    
    def entries_containing_verse(self, verse):
        # case where entry only has one verse
        list_entries_verse = verse.entries_startverse.all().exclude(removed=True)
        # case where entry has a start/end verse
        list_entries_passage = self.filter(startverse__lte=verse).exclude(removed=True).exclude(endverse=None).filter(endverse__gte=verse)
        
        return (list_entries_verse | list_entries_passage).values('id','title','startverse','endverse')
        
    def entries_passage_related(self, sverse, everse, entry_id=None, limit=5):
        if (everse == None):
            if entry_id and entry_id > 0:
                result = self.entries_containing_verse(sverse).exclude(removed=True).exclude(id=entry_id)[:limit]
            else:
                result = self.entries_containing_verse(sverse).exclude(removed=True)[:limit]
        else:    
            # case where entry only has start verse
            list_entries_verse = self.filter(startverse__gte=sverse, startverse__lte=everse, endverse=None).exclude(removed=True)
            # case where entry has start/end verse
            list_entries = self.all().exclude(endverse=None).exclude(startverse__gt=everse).exclude(endverse__lt=sverse).exclude(removed=True)
            
            if entry_id and entry_id > 0:
                result = list_entries_verse.exclude(id=entry_id) | list_entries.exclude(id=entry_id)
            else:
                result = list_entries_verse | list_entries
        
        return result[:limit].values('id','title','startverse','endverse')
        
    def entries_book_chapter_related(self, bookname, chp_ref):
        if chp_ref == None:
            return Entry.objects.filter(startverse__in=Verse.objects.filter(book__icontains=bookname)).exclude(removed=True).values('id','title','startverse','endverse','pub_date', 'created_by', 'num_votes')
        if bookname and chp_ref:
            return Entry.objects.filter(startverse__in=Verse.objects.filter(book__icontains=bookname, chapter_ref=chp_ref)).exclude(removed=True).values('id','title','startverse','endverse','pub_date','created_by', 'num_votes')
        
class Entry(models.Model):
    categories = models.ManyToManyField(Category, blank=True)
    startverse = models.ForeignKey(Verse, verbose_name='Start Verse', related_name='entries_startverse', null=True)
    num_votes = models.IntegerField(blank=True, default=0)
    endverse = models.ForeignKey(Verse, verbose_name='End Verse', null=True, blank=True, related_name='entries_endverse')
    title = models.CharField(max_length=512, blank=True, null=True)
    context_notes = models.TextField(blank=True, null=True, verbose_name='Context/Background Notes')
    notes = models.TextField(blank=True, null=True)
    pub_date = models.DateField(verbose_name='Date Posted', auto_now_add=True)
    created_by = models.ForeignKey(User)
    tags = models.ManyToManyField(Tag, blank=True)
    objects = EntryManager()
    removed = models.BooleanField(default=False)
    
    def __unicode__(self):
        s = self.startverse
        e = self.endverse
        
        if not e:
            return u'%s' % (s)
        if s.chapter_ref == e.chapter_ref and s.book == e.book:
            return u'%s-%s' % (s, e.verse_ref)
        else:
            return u'%s - %s' % (s, e)
    
    def get_book(self):
        return self.startverse.book
        
    def get_passage_ref(self):
        """Does not include the book name"""
        if self.endverse and self.startverse:
            if self.endverse.chapter_ref == self.startverse.chapter_ref:
                return str(self.startverse.chapter_ref) + ':' + str(self.startverse.verse_ref) + '-' + str(self.endverse.verse_ref)
            else:
                return str(self.startverse.chapter_ref) + ':' + str(self.startverse.verse_ref) + '-' + str(self.endverse.chapter_ref) + ':' + str(self.endverse.verse_ref)
        elif self.startverse:
            return str(self.startverse.chapter_ref) + ':' + str(self.startverse.verse_ref)
        else:
            return 'Invalid!'
            
    def related_entries_category(self, limit=5):
        categories = self.categories.all()
        entries = Entry.objects.filter(id=1).exclude(id=1);
        excluded = [self.id]
        for cat in categories:
            #print cat
            qs = cat.entry_set.all().exclude(removed=True).exclude(id__in=excluded)[:limit]
            for e in qs:
                excluded.append(e.id)
            entries = entries | qs
        
        if len(entries) <= limit: return entries.values('id','title','startverse','endverse')
        return random.sample(entries.values('id','title','startverse','endverse'), limit)
        
    def related_entries_tag(self, limit=5):
        tags = self.tags.all()
        entries = Entry.objects.filter(id=1).exclude(id=1);
        excluded = [self.id]
        for tag in tags:
            #print cat
            qs = tag.entry_set.all().exclude(removed=True).exclude(id__in=excluded)[:limit]
            for e in qs:
                excluded.append(e.id)
            entries = entries | qs
        
        if len(entries) <= limit: return entries.values('id','title','startverse','endverse')
        return random.sample(entries.values('id','title','startverse','endverse'), limit)
        
    class Meta:
        verbose_name_plural = "Entries"

class UIString(models.Model):
    name = models.CharField(max_length=64)
    content = models.CharField(max_length=256)
    last_modified = models.DateField(auto_now=True)
    
    def __unicode__(self):
        return self.name

class StaticContent(models.Model):
    name = models.CharField(max_length=64)
    content = models.TextField()
    last_modified = models.DateField(auto_now=True)
    
    def __unicode__(self):
        return self.name
        
class FAQ(models.Model):
    question = models.CharField(max_length=512)
    answer = models.TextField()
    last_modified = models.DateField(auto_now=True)
    
    def __unicode__(self):
        return self.question
        
class Update(models.Model):
    pub_date = models.DateTimeField(auto_now=True)
    content = models.TextField()